# 1. 코딩 테스트, 무엇을 어떻게 준비할까?

- [1. 코딩 테스트, 무엇을 어떻게 준비할까?](#1-코딩-테스트-무엇을-어떻게-준비할까)
  - [1. 코딩 테스트 개요](#1-코딩-테스트-개요)
    - [3. 복잡도](#3-복잡도)
      - [시간 복잡도](#시간-복잡도)
      - [공간 복잡도](#공간-복잡도)
      - [시간과 메모리 측정](#시간과-메모리-측정)

## 1. 코딩 테스트 개요

### 3. 복잡도

복잡도는 알고리즘의 성능을 나타내는 척도.

- 복잡도
  - 시간 복잡도(Time Complexity)
  - : 특정한 크기의 입력에 대하여 알고리즘이 얼마나 오래 걸리는가
  - 공간 복잡도(Space Complexity)
  - : 특정한 크기의 입력에 대하여 알고리즘이 얼마나 많은 메모리를 차지하는가

일반적으로 복잡도가 낮을수록 좋은 알고리즘

시간 복잡도 : 알고리즘을 위해 필요한 연산의 횟수
공간 복잡도 : 알고리즘을 위해 필요한 메모리의 양

보통 시간 복잡도와 공간 복잡도는 일종의 거래 관계(Trade-off)가 성립됨  
메모리를 더 많이 사용하는 대신에 반복되는 연산 생략하면서 복잡도 줄일 수 있음(메모이제이션)

#### 시간 복잡도

시간 제한 : 프로그램이 모든 입력을 받아 이를 처리하고 실행 결과를 출력하는 데까지 걸리는 시간

시간 복잡도 표현 : 빅오(Big-O) 표기법  
함수의 상한만을 나타냄.

| 빅오 표기법 |          명칭           |
| :---------: | :---------------------: |
|    O(1)     | 상수 시간(Contant time) |
|   O(logN)   |   로그 시간(Log time)   |
|    O(N)     |        선형 시간        |
|  O(NlogN)   |     로그 선형 시간      |
|    O(N²)    |        이차 시간        |
|    O(N³)    |        삼차 시간        |
|    O(2ⁿ)    |        지수 시간        |

=> 위쪽에 있을수록 더 빠름

연산 : 프로그래밍 언어에서 지원하는 사칙 연산, 비교 연산 등과 같은 기본 연산

문제의 조건을 확인하면 얼마나 효율적인 알고리즘을 작성해야 하는지 눈치 챌 수 있음

예) 데이터의 개수 N이 1,000만 개를 넘어가고, 시간 제한이 1초라면, 최악의 경우 O(N)의 시간 복잡도로 동작하는 알고리즘을 작성해야 함  
100억이나 1000억을 넘어가면 이진 탐색 같이 O(logN)의 시간 복잡도를 갖는 알고리즘을 작성해야 함

문제의 조건을 확인하고 사용할 수 있는 알고리즘을 좁혀 나가는 전략도 있음

예) 시간 제한이 1초인 경우

- N의 범위가 500인 경우
  - 시간 복잡도가 O(N³)인 알고리즘을 설계하면 문제를 풀 수 있다
- N의 범위가 2,000인 경우
  - 시간 복잡도가 O(N²)인 알고리즘을 설계하면 문제를 풀 수 있다
- N의 범위가 100,000인 경우
  - 시간 복잡도가 O(NlogN)인 알고리즘을 설계하면 문제를 풀 수 있다
- N의 범위가 10,000,000인 경우
  - 시간 복잡도가 O(N)인 알고리즘을 설계하면 문제를 풀 수 있다

#### 공간 복잡도

빅오 표기법 이용.  
일반적으로 메모리 사용량 기준은 MB 단위로 제시.

- int a[1000]: 4KB
- int a[1000000]: 4MB
- int a[2000][2000]: 16MB

보통 메모리 사용량을 128~512MB 정도로 제한. 일반적인 경우 데이터의 개수가 1,000만 단위가 넘어가지 않도록 알고리즘 설계를 해야 하는 것.

#### 시간과 메모리 측정

파이썬에서는 프로그램 수행 시간, 메모리 사용량 측정 가능. 실제 프로그램의 수행 시간을 측정하는 것은 알고리즘의 효율성을 측정하는 가장 기본적인 방법

```python
import time
start_time = time.time() #측정 시작

#프로그램 소스코드

end_time = time.time() #측정 종료
print("time: ", end_time - start_time) #수행 시간 출력
```
